{
  "archived": false,
  "branch": "main",
  "conda-forge.yml": {
    "bot": {
      "automerge": true
    },
    "build_platform": {
      "osx_arm64": "osx_64"
    },
    "conda_build": {
      "pkg_format": "2"
    },
    "conda_forge_output_validation": true,
    "github": {
      "branch_name": "main",
      "tooling_branch_name": "main"
    },
    "provider": {
      "linux_aarch64": "azure",
      "linux_ppc64le": "azure",
      "win": "azure"
    },
    "test": "native_and_emulated"
  },
  "feedstock_hash": "bbb03261be5cba8d8b667bb01f7deeee8f9d2c19",
  "feedstock_hash_ts": 1758032874,
  "feedstock_name": "r-softimpute",
  "hash_type": "sha256",
  "linux_64_meta_yaml": {
    "about": {
      "home": "https://CRAN.R-project.org/package=softImpute",
      "license": "GPL-2",
      "license_file": "/lib/R/share/licenses/GPL-2",
      "summary": "Iterative methods for matrix completion that use nuclear-norm regularization. There are two main approaches.The one approach uses iterative soft-thresholded svds to impute the missing values. The second approach uses alternating least squares. Both have an \"EM\" flavor, in that at each iteration the matrix is completed with the current estimate. For large matrices there is a special sparse-matrix class named \"Incomplete\" that efficiently handles all computations. The package includes procedures for centering and scaling rows, columns or both, and for computing low-rank SVDs on large sparse centered matrices (i.e. principal components)"
    },
    "build": {
      "number": "1",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r",
        "apcamargo"
      ]
    },
    "package": {
      "name": "r-softimpute",
      "version": "1.4_3"
    },
    "requirements": {
      "build": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ],
      "host": [
        "r-base",
        "r-matrix"
      ],
      "run": [
        "r-base",
        "r-matrix"
      ]
    },
    "schema_version": 0,
    "source": {
      "fn": "softImpute_1.4-3.tar.gz",
      "sha256": "3695447450e7b37980886d092135191d35ba1d719bcdd3a88164fd04c81eceb4",
      "url": [
        "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "$R -e \"library('softImpute')\""
      ]
    }
  },
  "linux_64_requirements": {
    "build": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ]
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "linux_aarch64_meta_yaml": {
    "about": {
      "home": "https://CRAN.R-project.org/package=softImpute",
      "license": "GPL-2",
      "license_file": "/lib/R/share/licenses/GPL-2",
      "summary": "Iterative methods for matrix completion that use nuclear-norm regularization. There are two main approaches.The one approach uses iterative soft-thresholded svds to impute the missing values. The second approach uses alternating least squares. Both have an \"EM\" flavor, in that at each iteration the matrix is completed with the current estimate. For large matrices there is a special sparse-matrix class named \"Incomplete\" that efficiently handles all computations. The package includes procedures for centering and scaling rows, columns or both, and for computing low-rank SVDs on large sparse centered matrices (i.e. principal components)"
    },
    "build": {
      "number": "1",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r",
        "apcamargo"
      ]
    },
    "package": {
      "name": "r-softimpute",
      "version": "1.4_3"
    },
    "requirements": {
      "build": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ],
      "host": [
        "r-base",
        "r-matrix"
      ],
      "run": [
        "r-base",
        "r-matrix"
      ]
    },
    "schema_version": 0,
    "source": {
      "fn": "softImpute_1.4-3.tar.gz",
      "sha256": "3695447450e7b37980886d092135191d35ba1d719bcdd3a88164fd04c81eceb4",
      "url": [
        "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "$R -e \"library('softImpute')\""
      ]
    }
  },
  "linux_aarch64_requirements": {
    "build": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ]
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "linux_ppc64le_meta_yaml": {
    "about": {
      "home": "https://CRAN.R-project.org/package=softImpute",
      "license": "GPL-2",
      "license_file": "/lib/R/share/licenses/GPL-2",
      "summary": "Iterative methods for matrix completion that use nuclear-norm regularization. There are two main approaches.The one approach uses iterative soft-thresholded svds to impute the missing values. The second approach uses alternating least squares. Both have an \"EM\" flavor, in that at each iteration the matrix is completed with the current estimate. For large matrices there is a special sparse-matrix class named \"Incomplete\" that efficiently handles all computations. The package includes procedures for centering and scaling rows, columns or both, and for computing low-rank SVDs on large sparse centered matrices (i.e. principal components)"
    },
    "build": {
      "number": "1",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r",
        "apcamargo"
      ]
    },
    "package": {
      "name": "r-softimpute",
      "version": "1.4_3"
    },
    "requirements": {
      "build": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ],
      "host": [
        "r-base",
        "r-matrix"
      ],
      "run": [
        "r-base",
        "r-matrix"
      ]
    },
    "schema_version": 0,
    "source": {
      "fn": "softImpute_1.4-3.tar.gz",
      "sha256": "3695447450e7b37980886d092135191d35ba1d719bcdd3a88164fd04c81eceb4",
      "url": [
        "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "$R -e \"library('softImpute')\""
      ]
    }
  },
  "linux_ppc64le_requirements": {
    "build": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ]
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "meta_yaml": {
    "about": {
      "home": "https://CRAN.R-project.org/package=softImpute",
      "license": "GPL-2",
      "license_file": "/lib/R/share/licenses/GPL-2",
      "summary": "Iterative methods for matrix completion that use nuclear-norm regularization. There are two main approaches.The one approach uses iterative soft-thresholded svds to impute the missing values. The second approach uses alternating least squares. Both have an \"EM\" flavor, in that at each iteration the matrix is completed with the current estimate. For large matrices there is a special sparse-matrix class named \"Incomplete\" that efficiently handles all computations. The package includes procedures for centering and scaling rows, columns or both, and for computing low-rank SVDs on large sparse centered matrices (i.e. principal components)"
    },
    "build": {
      "number": "1",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r",
        "apcamargo"
      ]
    },
    "package": {
      "name": "r-softimpute",
      "version": "1.4_3"
    },
    "requirements": {
      "build": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make",
        "m2w64_c_compiler_stub",
        "m2w64_c_stdlib_stub",
        "m2w64_fortran_compiler_stub",
        "filesystem",
        "sed",
        "coreutils",
        "zip"
      ],
      "host": [
        "r-base",
        "r-matrix"
      ],
      "run": [
        "r-base",
        "r-matrix"
      ]
    },
    "schema_version": 0,
    "source": {
      "fn": "softImpute_1.4-3.tar.gz",
      "sha256": "3695447450e7b37980886d092135191d35ba1d719bcdd3a88164fd04c81eceb4",
      "url": [
        "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "$R -e \"library('softImpute')\"",
        "\"%R%\" -e \"library('softImpute')\""
      ]
    }
  },
  "name": "r-softimpute",
  "osx_64_meta_yaml": {
    "about": {
      "home": "https://CRAN.R-project.org/package=softImpute",
      "license": "GPL-2",
      "license_file": "/lib/R/share/licenses/GPL-2",
      "summary": "Iterative methods for matrix completion that use nuclear-norm regularization. There are two main approaches.The one approach uses iterative soft-thresholded svds to impute the missing values. The second approach uses alternating least squares. Both have an \"EM\" flavor, in that at each iteration the matrix is completed with the current estimate. For large matrices there is a special sparse-matrix class named \"Incomplete\" that efficiently handles all computations. The package includes procedures for centering and scaling rows, columns or both, and for computing low-rank SVDs on large sparse centered matrices (i.e. principal components)"
    },
    "build": {
      "number": "1",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r",
        "apcamargo"
      ]
    },
    "package": {
      "name": "r-softimpute",
      "version": "1.4_3"
    },
    "requirements": {
      "build": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ],
      "host": [
        "r-base",
        "r-matrix"
      ],
      "run": [
        "r-base",
        "r-matrix"
      ]
    },
    "schema_version": 0,
    "source": {
      "fn": "softImpute_1.4-3.tar.gz",
      "sha256": "3695447450e7b37980886d092135191d35ba1d719bcdd3a88164fd04c81eceb4",
      "url": [
        "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "$R -e \"library('softImpute')\""
      ]
    }
  },
  "osx_64_requirements": {
    "build": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ]
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "osx_arm64_meta_yaml": {
    "about": {
      "home": "https://CRAN.R-project.org/package=softImpute",
      "license": "GPL-2",
      "license_file": "/lib/R/share/licenses/GPL-2",
      "summary": "Iterative methods for matrix completion that use nuclear-norm regularization. There are two main approaches.The one approach uses iterative soft-thresholded svds to impute the missing values. The second approach uses alternating least squares. Both have an \"EM\" flavor, in that at each iteration the matrix is completed with the current estimate. For large matrices there is a special sparse-matrix class named \"Incomplete\" that efficiently handles all computations. The package includes procedures for centering and scaling rows, columns or both, and for computing low-rank SVDs on large sparse centered matrices (i.e. principal components)"
    },
    "build": {
      "number": "1",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r",
        "apcamargo"
      ]
    },
    "package": {
      "name": "r-softimpute",
      "version": "1.4_3"
    },
    "requirements": {
      "build": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ],
      "host": [
        "r-base",
        "r-matrix"
      ],
      "run": [
        "r-base",
        "r-matrix"
      ]
    },
    "schema_version": 0,
    "source": {
      "fn": "softImpute_1.4-3.tar.gz",
      "sha256": "3695447450e7b37980886d092135191d35ba1d719bcdd3a88164fd04c81eceb4",
      "url": [
        "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "$R -e \"library('softImpute')\""
      ]
    }
  },
  "osx_arm64_requirements": {
    "build": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "make"
      ]
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "outputs_names": {
    "__set__": true,
    "elements": [
      "r-softimpute"
    ]
  },
  "parsing_error": false,
  "platforms": [
    "linux_64",
    "linux_aarch64",
    "linux_ppc64le",
    "osx_64",
    "osx_arm64",
    "win_64"
  ],
  "pr_info": {
    "__lazy_json__": "pr_info/r-softimpute.json"
  },
  "raw_meta_yaml": "{% set version = \"1.4-3\" %}\n{% set posix = 'm2-' if win else '' %}\n\npackage:\n  name: r-softimpute\n  version: {{ version|replace(\"-\", \"_\") }}\n\nsource:\n  fn: softImpute_{{ version }}.tar.gz\n  url:\n    - {{ cran_mirror }}/src/contrib/softImpute_{{ version }}.tar.gz\n    - {{ cran_mirror }}/src/contrib/Archive/softImpute/softImpute_{{ version }}.tar.gz\n  sha256: 3695447450e7b37980886d092135191d35ba1d719bcdd3a88164fd04c81eceb4\n\nbuild:\n  number: 1\n\n  rpaths:\n    - lib/R/lib/\n    - lib/\n\nrequirements:\n  build:\n    - {{ compiler('c') }}        # [not win]\n    - {{ stdlib(\"c\") }}          # [not win]\n    - {{ compiler('fortran') }}  # [not win]\n    - {{ compiler('m2w64_c') }}        # [win]\n    - {{ stdlib(\"m2w64_c\") }}          # [win]\n    - {{ compiler('m2w64_fortran') }}        # [win]\n    - {{ posix }}filesystem        # [win]\n    - {{ posix }}make\n    - {{ posix }}sed  # [win]\n    - {{ posix }}coreutils  # [win]\n    - {{ posix }}sed               # [win]\n    - {{ posix }}coreutils         # [win]\n    - {{ posix }}zip               # [win]\n    - cross-r-base {{ r_base }}    # [build_platform != target_platform]\n    - r-matrix                     # [build_platform != target_platform]\n  host:\n    - r-base\n    - r-matrix\n  run:\n    - r-base\n    - r-matrix\n\ntest:\n  commands:\n    - $R -e \"library('softImpute')\"           # [not win]\n    - \"\\\"%R%\\\" -e \\\"library('softImpute')\\\"\"  # [win]\n\nabout:\n  home: https://CRAN.R-project.org/package=softImpute\n  license: GPL-2\n  summary: Iterative methods for matrix completion that use nuclear-norm regularization. There are two main approaches.The one approach uses iterative soft-thresholded svds to impute the missing values. The second approach uses alternating least squares. Both have an \"EM\" flavor, in that at each iteration the matrix is completed\n    with the current estimate. For large matrices there is a special sparse-matrix class named \"Incomplete\" that efficiently handles all computations. The package includes procedures for centering and scaling rows, columns or both, and for computing low-rank SVDs on large sparse centered matrices (i.e. principal components)\n  license_file: {{ environ[\"PREFIX\"] }}/lib/R/share/licenses/GPL-2\n\nextra:\n  recipe-maintainers:\n    - conda-forge/r\n    - apcamargo\n",
  "req": {
    "__set__": true,
    "elements": [
      "c_compiler_stub",
      "c_stdlib_stub",
      "coreutils",
      "filesystem",
      "fortran_compiler_stub",
      "m2w64_c_compiler_stub",
      "m2w64_c_stdlib_stub",
      "m2w64_fortran_compiler_stub",
      "make",
      "r-base",
      "r-matrix",
      "sed",
      "zip"
    ]
  },
  "requirements": {
    "build": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "coreutils",
        "filesystem",
        "fortran_compiler_stub",
        "m2w64_c_compiler_stub",
        "m2w64_c_stdlib_stub",
        "m2w64_fortran_compiler_stub",
        "make",
        "sed",
        "zip"
      ]
    },
    "host": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "r-base",
        "r-matrix"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "fortran_compiler_stub",
        "r-base",
        "r-matrix"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "strong_exports": false,
  "total_requirements": {
    "build": {
      "__set__": true,
      "elements": [
        "c_compiler_stub",
        "c_stdlib_stub",
        "coreutils",
        "filesystem",
        "fortran_compiler_stub",
        "m2w64_c_compiler_stub",
        "m2w64_c_stdlib_stub",
        "m2w64_fortran_compiler_stub",
        "make",
        "sed",
        "zip"
      ]
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "url": [
    "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
    "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz"
  ],
  "version": "1.4_3",
  "version_pr_info": {
    "__lazy_json__": "version_pr_info/r-softimpute.json"
  },
  "win_64_meta_yaml": {
    "about": {
      "home": "https://CRAN.R-project.org/package=softImpute",
      "license": "GPL-2",
      "license_file": "/lib/R/share/licenses/GPL-2",
      "summary": "Iterative methods for matrix completion that use nuclear-norm regularization. There are two main approaches.The one approach uses iterative soft-thresholded svds to impute the missing values. The second approach uses alternating least squares. Both have an \"EM\" flavor, in that at each iteration the matrix is completed with the current estimate. For large matrices there is a special sparse-matrix class named \"Incomplete\" that efficiently handles all computations. The package includes procedures for centering and scaling rows, columns or both, and for computing low-rank SVDs on large sparse centered matrices (i.e. principal components)"
    },
    "build": {
      "number": "1",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r",
        "apcamargo"
      ]
    },
    "package": {
      "name": "r-softimpute",
      "version": "1.4_3"
    },
    "requirements": {
      "build": [
        "m2w64_c_compiler_stub",
        "m2w64_c_stdlib_stub",
        "m2w64_fortran_compiler_stub",
        "filesystem",
        "make",
        "sed",
        "coreutils",
        "zip"
      ],
      "host": [
        "r-base",
        "r-matrix"
      ],
      "run": [
        "r-base",
        "r-matrix"
      ]
    },
    "schema_version": 0,
    "source": {
      "fn": "softImpute_1.4-3.tar.gz",
      "sha256": "3695447450e7b37980886d092135191d35ba1d719bcdd3a88164fd04c81eceb4",
      "url": [
        "https://cran.r-project.org/src/contrib/softImpute_1.4-3.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/softImpute/softImpute_1.4-3.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "\"%R%\" -e \"library('softImpute')\""
      ]
    }
  },
  "win_64_requirements": {
    "build": {
      "__set__": true,
      "elements": [
        "coreutils",
        "filesystem",
        "m2w64_c_compiler_stub",
        "m2w64_c_stdlib_stub",
        "m2w64_fortran_compiler_stub",
        "make",
        "sed",
        "zip"
      ]
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base",
        "r-matrix"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  }
}