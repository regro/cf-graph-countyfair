{
  "archived": false,
  "branch": "main",
  "ci_support_linux_64_r_base4.4.yaml": "cdt_name:\n- conda\nchannel_sources:\n- conda-forge\nchannel_targets:\n- conda-forge main\ncran_mirror:\n- https://cran.r-project.org\ndocker_image:\n- quay.io/condaforge/linux-anvil-x86_64:alma9\npin_run_as_build:\n  r-base:\n    min_pin: x.x\n    max_pin: x.x\nr_base:\n- '4.4'\ntarget_platform:\n- linux-64\n",
  "conda-forge.yml": {
    "bot": {
      "automerge": true
    },
    "conda_build": {
      "pkg_format": "2"
    },
    "conda_forge_output_validation": true,
    "github": {
      "branch_name": "main",
      "tooling_branch_name": "main"
    }
  },
  "feedstock_hash": null,
  "feedstock_hash_ts": null,
  "feedstock_name": "r-nsprcomp",
  "hash_type": "sha256",
  "linux_64_meta_yaml": {
    "about": {
      "home": "https://sigg-iten.ch/research/",
      "license": "GPL-2.0-or-later",
      "license_family": "GPL3",
      "license_file": [
        "/lib/R/share/licenses/GPL-2"
      ],
      "summary": "Two methods for performing a constrained principal component analysis (PCA), where non-negativity and/or sparsity constraints are enforced on the principal axes (PAs). The function 'nsprcomp' computes one principal component (PC) after the other. Each PA is optimized such that the corresponding PC has maximum additional variance not explained by the previous components. In contrast, the function 'nscumcomp' jointly computes all PCs such that the cumulative variance is maximal. Both functions have the same interface as the 'prcomp' function from the 'stats' package (plus some extra parameters), and both return the result of the analysis as an object of class 'nsprcomp', which inherits from 'prcomp'. See <https://sigg-iten.ch/learningbits/2013/05/27/nsprcomp-is-on-cran/> and Sigg et al. (2008) <doi:10.1145/1390156.1390277> for more details."
    },
    "build": {
      "noarch": "generic",
      "number": "5",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r"
      ]
    },
    "package": {
      "name": "r-nsprcomp",
      "version": "0.5.1_2"
    },
    "requirements": {
      "build": [],
      "host": [
        "r-base"
      ],
      "run": [
        "r-base"
      ]
    },
    "schema_version": 0,
    "source": {
      "sha256": "2e95c877b7d45aa89cee7c90e496bd33dcb58d761851c0ca10cea45e630f8cfe",
      "url": [
        "https://cran.r-project.org/src/contrib/nsprcomp_0.5.1-2.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/nsprcomp/nsprcomp_0.5.1-2.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "$R -e \"library('nsprcomp')\""
      ]
    }
  },
  "linux_64_requirements": {
    "build": {
      "__set__": true,
      "elements": []
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "meta_yaml": {
    "about": {
      "home": "https://sigg-iten.ch/research/",
      "license": "GPL-2.0-or-later",
      "license_family": "GPL3",
      "license_file": [
        "/lib/R/share/licenses/GPL-2"
      ],
      "summary": "Two methods for performing a constrained principal component analysis (PCA), where non-negativity and/or sparsity constraints are enforced on the principal axes (PAs). The function 'nsprcomp' computes one principal component (PC) after the other. Each PA is optimized such that the corresponding PC has maximum additional variance not explained by the previous components. In contrast, the function 'nscumcomp' jointly computes all PCs such that the cumulative variance is maximal. Both functions have the same interface as the 'prcomp' function from the 'stats' package (plus some extra parameters), and both return the result of the analysis as an object of class 'nsprcomp', which inherits from 'prcomp'. See <https://sigg-iten.ch/learningbits/2013/05/27/nsprcomp-is-on-cran/> and Sigg et al. (2008) <doi:10.1145/1390156.1390277> for more details."
    },
    "build": {
      "noarch": "generic",
      "number": "5",
      "rpaths": [
        "lib/R/lib/",
        "lib/"
      ]
    },
    "extra": {
      "recipe-maintainers": [
        "conda-forge/r"
      ]
    },
    "package": {
      "name": "r-nsprcomp",
      "version": "0.5.1_2"
    },
    "requirements": {
      "build": [],
      "host": [
        "r-base"
      ],
      "run": [
        "r-base"
      ]
    },
    "schema_version": 0,
    "source": {
      "sha256": "2e95c877b7d45aa89cee7c90e496bd33dcb58d761851c0ca10cea45e630f8cfe",
      "url": [
        "https://cran.r-project.org/src/contrib/nsprcomp_0.5.1-2.tar.gz",
        "https://cran.r-project.org/src/contrib/Archive/nsprcomp/nsprcomp_0.5.1-2.tar.gz"
      ]
    },
    "test": {
      "commands": [
        "$R -e \"library('nsprcomp')\""
      ]
    }
  },
  "name": "r-nsprcomp",
  "outputs_names": {
    "__set__": true,
    "elements": [
      "r-nsprcomp"
    ]
  },
  "parsing_error": false,
  "platforms": [
    "linux_64"
  ],
  "pr_info": {
    "__lazy_json__": "pr_info/r-nsprcomp.json"
  },
  "raw_meta_yaml": "{% set version = '0.5.1-2' %}\n{% set posix = 'm2-' if win else '' %}\n\npackage:\n  name: r-nsprcomp\n  version: {{ version|replace(\"-\", \"_\") }}\n\nsource:\n  url:\n    - {{ cran_mirror }}/src/contrib/nsprcomp_{{ version }}.tar.gz\n    - {{ cran_mirror }}/src/contrib/Archive/nsprcomp/nsprcomp_{{ version }}.tar.gz\n  sha256: 2e95c877b7d45aa89cee7c90e496bd33dcb58d761851c0ca10cea45e630f8cfe\n\nbuild:\n  number: 5\n  noarch: generic\n  rpaths:\n    - lib/R/lib/\n    - lib/\n\nrequirements:\n  build:\n    - {{ posix }}zip               # [win]\n    - cross-r-base {{ r_base }}    # [build_platform != target_platform]\n  host:\n    - r-base\n  run:\n    - r-base\n\ntest:\n  commands:\n    - $R -e \"library('nsprcomp')\"           # [not win]\n    - \"\\\"%R%\\\" -e \\\"library('nsprcomp')\\\"\"  # [win]\n\nabout:\n  home: https://sigg-iten.ch/research/\n  license: GPL-2.0-or-later\n  summary: Two methods for performing a constrained principal component analysis (PCA), where\n    non-negativity and/or sparsity constraints are enforced on the principal axes (PAs).\n    The function 'nsprcomp' computes one principal component (PC) after the other. Each\n    PA is optimized such that the corresponding PC has maximum additional variance not\n    explained by the previous components. In contrast, the function 'nscumcomp' jointly\n    computes all PCs such that the cumulative variance is maximal. Both functions have\n    the same interface as the 'prcomp' function from the 'stats' package (plus some\n    extra parameters), and both return the result of the analysis as an object of class\n    'nsprcomp', which inherits from 'prcomp'. See <https://sigg-iten.ch/learningbits/2013/05/27/nsprcomp-is-on-cran/>\n    and Sigg et al. (2008) <doi:10.1145/1390156.1390277> for more details.\n  license_family: GPL3\n  license_file:\n    - {{ environ[\"PREFIX\"] }}/lib/R/share/licenses/GPL-2\n\nextra:\n  recipe-maintainers:\n    - conda-forge/r\n\n# Package: nsprcomp\n# Authors@R: c( person(\"Christian\", \"Sigg\", email = \"christian@sigg-iten.ch\", role = c(\"aut\", \"cre\"), comment = c(ORCID = \"0000-0003-1067-9224\")), person(\"R Core team\", role = \"ctb\", comment = \"prcomp interface, formula implementation and documentation\"))\n# Version: 0.5.1-2\n# Title: Non-Negative and Sparse PCA\n# Description: Two methods for performing a constrained principal component analysis (PCA), where non-negativity and/or sparsity constraints are enforced on the principal axes (PAs). The function 'nsprcomp' computes one principal component (PC) after the other. Each PA is optimized such that the corresponding PC has maximum additional variance not explained by the previous components. In contrast, the function 'nscumcomp' jointly computes all PCs such that the cumulative variance is maximal. Both functions have the same interface as the 'prcomp' function from the 'stats' package (plus some extra parameters), and both return the result of the analysis as an object of class 'nsprcomp', which inherits from 'prcomp'. See <https://sigg-iten.ch/learningbits/2013/05/27/nsprcomp-is-on-cran/> and Sigg et al. (2008) <doi:10.1145/1390156.1390277> for more details.\n# URL: https://sigg-iten.ch/research/\n# BugReports: https://github.com/chrsigg/nsprcomp/issues\n# License: GPL (>= 2)\n# Depends: R (>= 3.4.0)\n# Imports: stats\n# Suggests: MASS, testthat (>= 0.8), roxygen2\n# RoxygenNote: 6.0.1\n# NeedsCompilation: no\n# Packaged: 2018-06-05 07:40:43 UTC; chrsigg\n# Author: Christian Sigg [aut, cre] (<https://orcid.org/0000-0003-1067-9224>), R Core team [ctb] (prcomp interface, formula implementation and documentation)\n# Maintainer: Christian Sigg <christian@sigg-iten.ch>\n# Repository: CRAN\n# Date/Publication: 2018-06-05 11:48:17 UTC\n",
  "req": {
    "__set__": true,
    "elements": [
      "r-base"
    ]
  },
  "requirements": {
    "build": {
      "__set__": true,
      "elements": []
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "strong_exports": false,
  "total_requirements": {
    "build": {
      "__set__": true,
      "elements": []
    },
    "host": {
      "__set__": true,
      "elements": [
        "r-base"
      ]
    },
    "run": {
      "__set__": true,
      "elements": [
        "r-base"
      ]
    },
    "test": {
      "__set__": true,
      "elements": []
    }
  },
  "url": [
    "https://cran.r-project.org/src/contrib/nsprcomp_0.5.1-2.tar.gz",
    "https://cran.r-project.org/src/contrib/Archive/nsprcomp/nsprcomp_0.5.1-2.tar.gz"
  ],
  "version": "0.5.1_2",
  "version_pr_info": {
    "__lazy_json__": "version_pr_info/r-nsprcomp.json"
  }
}